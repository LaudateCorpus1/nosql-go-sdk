//
// Copyright (C) 2019 Oracle and/or its affiliates. All rights reserved.
//
// Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl
//
// Please see LICENSE.txt file included in the top-level directory of the
// appropriate download for a copy of the license and additional information.
//

// Package idcs provides authorization provider implementations based on Oracle
// IDCS (IDentity Cloud Service) for clients that connect to the NoSQL cloud service.
package idcs

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/oracle/nosql-go-sdk/nosqldb/auth"
	"github.com/oracle/nosql-go-sdk/nosqldb/httputil"
	"github.com/oracle/nosql-go-sdk/nosqldb/internal/sdkutil"
	"github.com/oracle/nosql-go-sdk/nosqldb/jsonutil"
	"github.com/oracle/nosql-go-sdk/nosqldb/logger"
	"github.com/oracle/nosql-go-sdk/nosqldb/nosqlerr"
)

const (
	// andcAudiencePrefix represents prefix of the audience of an OAuth resource.
	// The full audience is in the form of:
	//
	//   urn:opc:andc:entitlementid={ENTITLEMENT_ID}
	//
	// Where the ENTITLEMENT_ID is dynamically generated by Oracle Cloud.
	andcAudiencePrefix = "urn:opc:andc:entitlementid="

	// andcScope represents the scope of ANDC application. It can be used to
	// acquire an access token to build the fully qualified scope along with
	// audience.
	//
	// This is the only one OAuth scope for ANDC application.
	andcScope = "urn:opc:andc:resource:consumer::all"

	// IDCS OAuth2 access token endpoint.
	tokenEndpoint = "/oauth2/v1/token"

	// IDCS Apps endpoint used to find application info.
	appEndpoint = "/admin/v1/Apps"

	// psmAppFilter represents the filter using service type URN to get PSMApp
	// metadata from IDCS when provider attempts to acquire PSM access token
	// using PSMApp client id and secret.
	// The PSMApp metadata contains PSMApp client id, secret and primary
	// audience of PSM for the cloud account.
	psmAppFilter = "?filter=serviceTypeURN+eq+%22PSMResourceTenatApp%22"

	// psmScope is used for acquiring PSM access token.
	psmScope = "urn:opc:resource:consumer::all"

	// Property names in IDCS properties file.
	// The entitlement_id property will be deprecated eventually.
	idcsURLProp       = "idcs_url"
	credsFileProp     = "creds_file"
	entitlementIdProp = "entitlement_id"

	// IDCS fully qualified scope to acquire IDCS access token.
	idcsScope = "urn:opc:idm:__myscopes__"
)

// tokenKind represent the kind of token.
type tokenKind string

const (
	// Service token kind.
	ServiceToken tokenKind = "SERVICE"
	// Account token kind.
	AccountToken tokenKind = "ACCOUNT"
)

// ordinal returns the ordinal of the tokenKind.
func (k tokenKind) ordinal() int {
	switch k {
	case AccountToken:
		return 1
	default:
		return 0
	}
}

// The default IDCS properties file ~/.andc/idcs.props
var defaultIDCSPropsFile = filepath.Join(userHomeDir(), ".andc", "idcs.props")

// Default options for the provider.
var defaultOptions = auth.ProviderOptions{
	Timeout:      12 * time.Second,
	ExpiryWindow: 2 * time.Minute,
	Logger:       logger.DefaultLogger,
	HTTPClient:   httputil.DefaultHTTPClient,
}

// AccessTokenProvider is an access token provider based on Oracle IDCS (IDentity Cloud Service).
// It acquires access tokens from IDCS using credentials provided by a CredentialsProvider
// which is a PropertiesCredentialsProvider by default and can be configured by applications.
//
// This provider requires an IDCS URL that represents a tenant-specific URL generated by IDCS.
// You can find the IDCS URL specific to your tenant as follows:
//
// 1. Go to IDCS login page, login with your Oracle cloud account.
//
// 2. If login succeeds, you will be redirected to the IDCS admin console.
// The address bar of browser displays the admin console URL, which usually
// is in the form:
//
//   https://{tenantId}.identity.oraclecloud.com/ui/v1/adminconsole
//
// Where the "https://{tenantId}.identity.oraclecloud.com" portion is the desired URL.
//
// This implements the nosqldb.AuthorizationProvider interface.
type AccessTokenProvider struct {
	// IDCS URL specific to the tenant.
	idcsURL string

	// IDCS host.
	idcsHost string

	// Fully qualified scope of ANDC application.
	andcFQS string

	// Fully qualified scope of PSM application.
	psmFQS string

	// Credentials provider.
	// If not specified, the default PropertiesCredentialsProvider is used.
	credsProvider CredentialsProvider

	// OAuth request timeout.
	// If not specified, the default timeout is used.
	timeout time.Duration

	// A Logger.
	// If not specified, use logger.DefaultLogger.
	logger *logger.Logger

	// An HTTPClient.
	// If not specified, use http.DefaultHTTPClient.
	httpClient *httputil.HTTPClient

	// Cached token that can be reused when they are valid.
	cachedTokens [2]*auth.Token

	// A duration of time that determines how far ahead of service access token
	// expiry the provider is allowed to renew the access token.
	expiryWindow time.Duration

	mutex sync.RWMutex
	wg    sync.WaitGroup
}

// NewAccessTokenProvider creates an AccessTokenProvider that acquires access
// tokens from Oracle IDCS using the IDCS URL and credentials specified in the
// default IDCS properties file ~/.andc/idcs.props, where each property should
// be specified in a single line of the form:
//
//   propertyName=propertyValue
//
// The supported property names are case-sensitive and listed as follows:
//
//   idcs_url
//   creds_file
//   entitlement_id
//
// The "idcs_url" property specifies a tenant-specific IDCS URL. It is required.
//
// The "creds_file" property specifies the path to credentials properties file.
// It is optional. If not set, the default file ~/.andc/credentials is used.
//
// The "entitlement_id" property specifies the service entitlement id. It is
// optional and will be deprecated.
//
// This is a variadic function that may be invoked with zero or more arguments
// for the options parameter, but only the first argument for the options
// parameter, if specified, is used, others are ignored.
func NewAccessTokenProvider(options ...auth.ProviderOptions) (*AccessTokenProvider, error) {
	return NewAccessTokenProviderWithFile(defaultIDCSPropsFile, options...)
}

// NewAccessTokenProviderWithFile creates an AccessTokenProvider that acquires
// access tokens from Oracle IDCS using the IDCS URL and credentials specified
// in the idcsPropsFile, where each property should be specified in a single
// line of the form:
//
//   propertyName=propertyValue
//
// The supported property names are case-sensitive and listed as follows:
//
//   idcs_url
//   creds_file
//   entitlement_id
//
// The "idcs_url" property specifies a tenant-specific IDCS URL. It is required.
//
// The "creds_file" property specifies the path to credentials properties file.
// It is optional. If not set, the default file ~/.andc/credentials is used.
//
// The "entitlement_id" property specifies the service entitlement id. It is
// optional and will be deprecated.
//
// This is a variadic function that may be invoked with zero or more arguments
// for the options parameter, but only the first argument for the options
// parameter, if specified, is used, others are ignored.
func NewAccessTokenProviderWithFile(idcsPropsFile string, options ...auth.ProviderOptions) (*AccessTokenProvider, error) {
	props, err := sdkutil.NewProperties(idcsPropsFile)
	if err != nil {
		return nil, err
	}

	props.Load()
	if err = props.Err(); err != nil {
		return nil, err
	}

	idcsURL, err := props.Get(idcsURLProp)
	if err != nil {
		return nil, err
	}

	// Ignore the errors as credentials file and entitlement id are optional.
	credsFile, _ := props.Get(credsFileProp)
	entitlementId, _ := props.Get(entitlementIdProp)

	return newIDCSProvider(idcsURL, entitlementId, credsFile, options...)
}

// NewAccessTokenProviderWithURL creates an AccessTokenProvider that acquires
// access tokens from Oracle IDCS using the specified IDCS URL and credentials
// from the default credentials properties file ~/.andc/credentials.
//
// This is a variadic function that may be invoked with zero or more arguments
// for the options parameter, but only the first argument for the options
// parameter, if specified, is used, others are ignored.
func NewAccessTokenProviderWithURL(idcsURL string, options ...auth.ProviderOptions) (*AccessTokenProvider, error) {
	return newIDCSProvider(idcsURL, "", "", options...)
}

// NewAccessTokenProviderWithEntitlementId creates an AccessTokenProvider that
// acquires access tokens from Oracle IDCS using the specified IDCS URL, service
// entitlement id and credentials from the default credentials properties file
// ~/.andc/credentials.
//
// This is a variadic function that may be invoked with zero or more arguments
// for the options parameter, but only the first argument for the options
// parameter, if specified, is used, others are ignored.
//
// This function will be deprecated.
func NewAccessTokenProviderWithEntitlementId(idcsURL, entitlementId string, options ...auth.ProviderOptions) (*AccessTokenProvider, error) {
	return newIDCSProvider(idcsURL, entitlementId, "", options...)
}

// newIDCSProvider creates an AccessTokenProvider that acquires access tokens
// from Oracle IDCS using the specified IDCS URL, service entitlement id and
// credentials from the specified credentials properties file.
//
// This is a variadic function that may be invoked with zero or more arguments
// for the options parameter, but only the first argument for the options
// parameter, if specified, is used, others are ignored.
func newIDCSProvider(idcsURL, entitlementId, credsFile string, options ...auth.ProviderOptions) (*AccessTokenProvider, error) {
	url, hostname, err := parseIDCSURL(idcsURL)
	if err != nil {
		return nil, err
	}

	// Initialize with default options.
	opt := defaultOptions
	// Overwrite with supplied values if they are valid.
	if len(options) > 0 {
		v := &options[0]
		if v.Timeout >= time.Millisecond {
			opt.Timeout = v.Timeout
		}

		if v.ExpiryWindow > 0 {
			opt.ExpiryWindow = v.ExpiryWindow
		}

		if v.Logger != nil {
			opt.Logger = v.Logger
		}

		if v.HTTPClient != nil {
			opt.HTTPClient = v.HTTPClient
		}
	}

	var credsProvider CredentialsProvider
	if credsFile != "" {
		credsProvider, err = NewPropertiesCredentialsProviderWithFile(credsFile)
		if err != nil {
			return nil, err
		}
	}

	p := &AccessTokenProvider{
		idcsURL:       url,
		idcsHost:      hostname,
		timeout:       opt.Timeout,
		expiryWindow:  opt.ExpiryWindow,
		logger:        opt.Logger,
		httpClient:    opt.HTTPClient,
		credsProvider: credsProvider,
	}

	// Sets andcFQS if entitlementId is provided.
	if entitlementId != "" {
		p.andcFQS = andcAudiencePrefix + entitlementId + andcScope
	}

	return p, nil
}

// AuthorizationScheme returns "Bearer" for this provider which means the bearer
// who holds the access token can access authorized resources.
func (p *AccessTokenProvider) AuthorizationScheme() string {
	return auth.BearerToken
}

// AuthorizationString returns an authorization string used for the specified
// request, which is in the form:
//
//   Bearer <access_token>
//
func (p *AccessTokenProvider) AuthorizationString(req auth.Request) (auth string, err error) {
	kind := tokenKind(req.Value())
	switch kind {
	case AccountToken, ServiceToken:
	default:
		return "", fmt.Errorf("unknown access token kind: %s", kind)
	}

	token, ok, needRefresh := p.getCachedToken(kind)
	if ok {
		if needRefresh {
			p.wg.Add(1)
			go func() {
				defer p.wg.Done()
				p.acquireAccessToken(kind)
			}()
		}

		return token.AuthString(), nil
	}

	token, err = p.acquireAccessToken(kind)
	if err != nil {
		return "", err
	}

	return token.AuthString(), nil
}

// bearer token providers don't do anything with request signing
func (p *AccessTokenProvider) SignHttpRequest(req *http.Request) error {
	return nil
}

// Close releases resources allocated by the provider.
func (p *AccessTokenProvider) Close() error {
	p.wg.Wait()
	return nil
}

// SetCredentialsProvider sets a credentials provider for the AccessTokenProvider.
func (p *AccessTokenProvider) SetCredentialsProvider(credsProvider CredentialsProvider) {
	p.credsProvider = credsProvider
}

// getCachedToken looks for the token of specified token kind from cache and
// checks if the cached token is valid. If the desired token is a service token
// this method also checks if it needs to refresh.
func (p *AccessTokenProvider) getCachedToken(kind tokenKind) (token *auth.Token, ok bool, needRefresh bool) {
	p.mutex.RLock()
	token = p.cachedTokens[kind.ordinal()]
	p.mutex.RUnlock()

	if token == nil {
		return
	}

	ok = !token.Expired()
	needRefresh = kind == ServiceToken && token.NeedRefresh(p.expiryWindow)
	return
}

// acquireAccessToken acquires an access token for the specified kind from the
// remote authorization server.
func (p *AccessTokenProvider) acquireAccessToken(kind tokenKind) (token *auth.Token, err error) {
	p.mutex.Lock()
	defer p.mutex.Unlock()

	switch kind {
	case AccountToken:
		token, err = p.accountAccessToken()
	case ServiceToken:
		token, err = p.serviceAccessToken()
	default:
		return nil, fmt.Errorf("unknown access token kind: %s", kind)
	}

	if err != nil {
		return nil, err
	}

	p.cachedTokens[kind.ordinal()] = token
	return token, nil
}

// accountAccessToken acquires an account access token from IDCS.
//
// The following operations require an account access token:
//
//   Create tables
//   Drop tables
//   Change table limits
//   List tables
//
func (p *AccessTokenProvider) accountAccessToken() (token *auth.Token, err error) {
	if err = p.findOAuthScopes(); err != nil {
		return
	}

	if p.psmFQS != "" {
		return p.getAccessTokenByPassword(p.psmFQS)
	}

	return p.getAccessTokenByPSMApp()
}

// serviceAccessToken acquires a service access token from IDCS.
func (p *AccessTokenProvider) serviceAccessToken() (token *auth.Token, err error) {
	if p.andcFQS == "" {
		if err = p.findOAuthScopes(); err != nil {
			return nil, err
		}

		if p.andcFQS == "" {
			return nil, nosqlerr.NewIllegalArgument("unable to find service scope from OAuth client. " +
				"If using custom OAuth client, please check client credentials. " +
				"If using ANDC OAuth client, please check client credentials and service entitlement id.")
		}
	}

	return p.getAccessTokenByPassword(p.andcFQS)
}

// findOAuthScopes looks for PSM and ANDC FQS (fully qualified scopes) from allowed scopes of OAuth client.
func (p *AccessTokenProvider) findOAuthScopes() error {
	if p.andcFQS != "" && p.psmFQS != "" {
		return nil
	}

	creds, err := p.getCredentials()
	if err != nil {
		return err
	}

	// Try to get access token by client credentials grant.
	req := &accessTokenRequest{
		clientCreds: creds[0],
		scope:       idcsScope,
		grantType:   clientCredentialsGrant,
	}

	token, err := p.getAccessToken(req)
	if err != nil {
		if nosqlerr.Is(err, nosqlerr.InvalidAuthorization) {
			p.logger.Info("unable to find FQS from OAuth client %s: %v", creds[0].Alias, err)
			// Returns a nil error. The caller is responsible for taking actions
			// accordingly upon receiving empty andcFQS and psmFQS.
			return nil
		}
		return err
	}

	headers := createHttpHeaders(p.idcsHost, token.AuthString(), httputil.AppScimJson)
	url := p.idcsURL + appEndpoint + "?filter=name+eq+%22" + creds[0].Alias + "%22"
	resp, err := p.doGetRequest(url, headers)
	if err != nil {
		return nosqlerr.NewIllegalState("Error getting client metadata from "+
			"Identity Cloud Service: %v", err)
	}

	if resp.Code > 299 {
		return handleIDCSErrors(resp, "Getting client metadata",
			"Please verify if the OAuth client is configured properly.")
	}

	fqsList, err := parseFQSFromJSON(resp.Body)
	if err != nil {
		return err
	}

	for _, fqs := range fqsList {
		if strings.HasPrefix(fqs, andcAudiencePrefix) {
			p.andcFQS = fqs
		} else if strings.HasSuffix(fqs, psmScope) {
			p.psmFQS = fqs
		}
	}

	return nil
}

// psmAppInfo represents a PSM application information that contains client id,
// client secret and primary audience.
type psmAppInfo struct {
	clientId     string
	clientSecret []byte
	audience     string
}

// getPSMApp gets PSM application metadata from IDCS. The secret of PSMApp will
// be hidden by IDCS, if the request does not specify a PSMApp secret, return an
// error to ask users to create a custom OAuth client.
//
// This method will be deprecated.
func (p *AccessTokenProvider) getPSMApp(auth string) (*psmAppInfo, error) {
	url := p.idcsURL + appEndpoint + psmAppFilter
	headers := createHttpHeaders(p.idcsHost, auth, httputil.AppScimJson)
	resp, err := p.doGetRequest(url, headers)
	if err != nil {
		return nil, nosqlerr.NewIllegalState("Error getting account metadata from Identity Cloud Service, "+
			"unable to acquire account access token. Error: %v", err)
	}

	if resp.Code >= 299 {
		err = handleIDCSErrors(resp, "Getting account metadata",
			"Please grant user Identity Domain Administrator or Application Administrator role.")
		return nil, err
	}

	return parsePSMAppFromJSON(resp.Body)
}

// getAccessToken gets access token from IDCS.
func (p *AccessTokenProvider) getAccessToken(req *accessTokenRequest) (token *auth.Token, err error) {
	if req == nil {
		return nil, nosqlerr.NewIllegalArgument("access token request is nil")
	}

	authUrl := p.idcsURL + tokenEndpoint
	headers := createHttpHeaders(p.idcsHost, req.authHeader(), httputil.AppURLEncodedForm)
	payload, err := req.body()
	if err != nil {
		return nil, err
	}

	payload = url.PathEscape(payload)
	buf := httputil.UTF8Encode(payload)
	resp, err := p.doPostRequest(authUrl, buf, headers)
	if err != nil {
		return nil, nosqlerr.NewIllegalState("Error acquiring access token with scope %q: %v", req.scope, err)
	}

	if resp.Code > 299 {
		err = handleTokenErrorResponse(resp, p.logger)
		return nil, err
	}

	// Try to parse access token from response body. A valid response from IDCS
	// is a well-formed JSON that contains the required "access_token" field.
	token, err = parseTokenFromJSON(resp.Body)
	if err != nil {
		return nil, nosqlerr.NewIllegalState("unable to parse access token: %v", err)
	}

	return token, nil
}

// doGetRequest is a convenience method used to send HTTP GET requests to the
// server using specified url and headers.
func (p *AccessTokenProvider) doGetRequest(url string, headers map[string]string) (*httputil.Response, error) {
	return httputil.DoRequest(context.Background(), p.httpClient, p.timeout, http.MethodGet, url, nil, headers, p.logger)
}

// doPostRequest is a convenience method used to send HTTP POST requests to the
// server using specified url, request body and headers.
func (p *AccessTokenProvider) doPostRequest(url string, body []byte, headers map[string]string) (*httputil.Response, error) {
	return httputil.DoRequest(context.Background(), p.httpClient, p.timeout, http.MethodPost, url, body, headers, p.logger)
}

// getAccessTokenByPSMApp acquires account access token using PSMApp provisioned
// by Oracle for each tenant.
//
// This method is kept for the backward compatibility if users are using the
// client id and secret from the ANDC application. This method would not work
// after IDCS hides client secret of Oracle-created Applications.
//
// This method will be deprecated eventually.
func (p *AccessTokenProvider) getAccessTokenByPSMApp() (token *auth.Token, err error) {
	creds, err := p.getCredentials()
	if err != nil {
		return
	}

	// Acquires IDCS access token by password grant.
	req := &accessTokenRequest{
		clientCreds: creds[0],
		userCreds:   creds[1],
		scope:       idcsScope,
		grantType:   passwordGrant,
	}

	token, err = p.getAccessToken(req)
	if err != nil {
		if nosqlerr.Is(err) {
			return nil, err
		}

		return nil, nosqlerr.NewIllegalState("Error acquiring Identity Cloud Service access token, "+
			"unable to get metadata to proceed acquiring account access token. "+
			"Error: %v", err)
	}

	// Looks up audience, client id and secret of PSMApp.
	psmApp, err := p.getPSMApp(token.AuthString())
	if err != nil {
		if nosqlerr.Is(err) {
			return nil, err
		}

		return nil, nosqlerr.NewIllegalState("Error finding required metadata from "+
			"Identity Cloud Service, unable to proceed acquiring account access token. "+
			"Error: %v", err)
	}

	// Sets psmFQS.
	p.psmFQS = psmApp.audience + psmScope

	// Acquires PSM access token by password grant.
	req = &accessTokenRequest{
		clientCreds: IDCSCredentials{
			Alias:  psmApp.clientId,
			Secret: psmApp.clientSecret,
		},
		userCreds: creds[1],
		scope:     p.psmFQS,
		grantType: passwordGrant,
	}

	return p.getAccessToken(req)
}

// getAccessTokenByPassword acquires access token from IDCS by password grant.
func (p *AccessTokenProvider) getAccessTokenByPassword(scope string) (token *auth.Token, err error) {
	creds, err := p.getCredentials()
	if err != nil {
		return
	}

	req := &accessTokenRequest{
		clientCreds: creds[0],
		userCreds:   creds[1],
		scope:       scope,
		grantType:   passwordGrant,
	}

	return p.getAccessToken(req)
}

// getCredentials gets client and user credentials from the credentials provider.
func (p *AccessTokenProvider) getCredentials() (creds []IDCSCredentials, err error) {
	if p.credsProvider == nil {
		// Try to create and use the default PropertiesCredentialsProvider that
		// gets credentials from ~/.andc/credentials.
		p.credsProvider, err = NewPropertiesCredentialsProvider()
		if err != nil {
			return nil, nosqlerr.NewIllegalArgument("CredentialsProvider not specified")
		}
	}

	creds = make([]IDCSCredentials, 2)
	creds[0], err = p.credsProvider.OAuthClientCredentials()
	if err != nil {
		return nil, nosqlerr.NewIllegalArgument("OAuth client credentials unavailable: %v", err)
	}

	creds[1], err = p.credsProvider.UserCredentials()
	if err != nil {
		return nil, nosqlerr.NewIllegalArgument("User credentials unavailable: %v", err)
	}

	return creds, nil
}

// parseTokenFromJSON parses access token from the specified JSON which must
// contain the required "access_token" field and optional "token_type" and
// "expires_in" fields that represent the access token, token type and expiry
// time of the access token respectively.
func parseTokenFromJSON(data []byte) (token *auth.Token, err error) {
	var m map[string]interface{}
	if err = json.Unmarshal(data, &m); err != nil {
		return nil, err
	}

	accessToken, ok := jsonutil.GetStringFromObject(m, "access_token")
	if !ok {
		return nil, fmt.Errorf("cannot parse access token from JSON %q", string(data))
	}

	tokenType, ok := jsonutil.GetStringFromObject(m, "token_type")
	if !ok {
		tokenType = auth.BearerToken
	}

	var expiresIn time.Duration
	expiresInSec, ok := jsonutil.GetNumberFromObject(m, "expires_in")
	if ok {
		expiresIn = time.Duration(int64(expiresInSec)) * time.Second
	}

	token = auth.NewToken(accessToken, tokenType, expiresIn)
	return token, nil
}

// parseFQSFromJSON parses and returns FQS from the specified JSON.
func parseFQSFromJSON(body []byte) ([]string, error) {
	res, err := parseResourcesFromScimListResponse(body, false)
	if err != nil {
		if nosqlerr.Is(err) {
			return nil, err
		}
		return nil, nosqlerr.NewIllegalState("failed to parse FQS from JSON response: %s, got error: %v",
			string(body), err)
	}

	fqs, err := getArrayElementValuesFromResources(res, true, "allowedScopes", "fqs")
	if err != nil {
		if nosqlerr.Is(err) {
			return nil, err
		}
		return nil, nosqlerr.NewIllegalState("failed to parse FQS from JSON response: %s, got error: %v",
			string(body), err)
	}
	return fqs, nil
}

// parsePSMAppFromJSON parses and returns PSM application information from
// the specified JSON.
func parsePSMAppFromJSON(body []byte) (*psmAppInfo, error) {
	res, err := parseResourcesFromScimListResponse(body, false)
	if err != nil {
		if nosqlerr.Is(err, nosqlerr.InsufficientPermission) {
			return nil, nosqlerr.New(nosqlerr.InsufficientPermission,
				"please grant user Identity Domain Administrator or "+
					"Application Administrator role. %v", err)
		}
		return nil, nosqlerr.NewIllegalState("failed to parse PSM application info "+
			"from JSON response: %q, got error: %v", string(body), err)
	}

	oauthId := "name"
	aud := "audience"
	secret := "clientSecret"
	values, err := getStringValuesFromResources(res, oauthId, aud, secret)
	if err != nil {
		return nil, err
	}

	var ok bool
	if _, ok = values[oauthId]; !ok {
		return nil, nosqlerr.NewIllegalState("failed to parse PSM application info "+
			"from JSON response: %q, the required account metadata \"%s\" is missing.", string(body), oauthId)
	}

	if _, ok = values[aud]; !ok {
		return nil, nosqlerr.NewIllegalState("failed to parse PSM application info "+
			"from JSON response: %q, the required account metadata \"%s\" is missing.", string(body), aud)
	}

	if _, ok = values[secret]; !ok {
		return nil, nosqlerr.NewIllegalState("account metadata does not have a secret, "+
			"unable to acquire account access token. Must create a custom "+
			"OAuth client first. Account metadata: %q", string(body))
	}

	psm := &psmAppInfo{
		clientId:     values[oauthId],
		clientSecret: []byte(values[secret]),
		audience:     values[aud],
	}
	return psm, nil
}
